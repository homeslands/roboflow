// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// ControlMode defines model for ControlMode.
type ControlMode = string

// CreateQRLocationRequest defines model for CreateQRLocationRequest.
type CreateQRLocationRequest struct {
	// Metadata The metadata of the location.
	Metadata map[string]any `json:"metadata"`

	// Name The name of the location.
	Name string `json:"name"`

	// QrCode The QR code of the location.
	QrCode string `json:"qrCode"`
}

// CreateRaybotCommandRequest defines model for CreateRaybotCommandRequest.
type CreateRaybotCommandRequest struct {
	Inputs json.RawMessage   `json:"inputs"`
	Type   RaybotCommandType `json:"type"`
}

// CreateRaybotRequest defines model for CreateRaybotRequest.
type CreateRaybotRequest struct {
	// Name The name of the raybot.
	Name string `json:"name"`
}

// CreateWorkflowRequest defines model for CreateWorkflowRequest.
type CreateWorkflowRequest struct {
	// Name The name of the workflow.
	Name string `json:"name"`

	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// Data The data of the workflow.
	Data json.RawMessage `json:"data"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Code custom roboflow error code
	Code string `json:"code"`

	// Message custom roboflow error message
	Message string        `json:"message"`
	Details *[]FieldError `json:"details,omitempty"`
}

// FieldError defines model for FieldError.
type FieldError struct {
	// Field field name
	Field string `json:"field"`

	// Message error message
	Message string `json:"message"`
}

// NodeType defines model for NodeType.
type NodeType = string

// Position defines model for Position.
type Position struct {
	X float32 `json:"x"`
	Y float32 `json:"y"`
}

// QRLocationResponse defines model for QRLocationResponse.
type QRLocationResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// Name The name of the location.
	Name string `json:"name"`

	// QrCode The QR code of the location.
	QrCode string `json:"qrCode"`

	// Metadata The metadata of the location.
	Metadata map[string]any `json:"metadata"`

	// CreatedAt The date and time when the location was created.
	CreatedAt time.Time `json:"createdAt"`

	// UpdatedAt The date and time when the location was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// QRLocationsListResponse defines model for QRLocationsListResponse.
type QRLocationsListResponse struct {
	Items []QRLocationResponse `json:"items"`

	// TotalItems The total number of locations.
	TotalItems int64 `json:"totalItems"`
}

// RaybotCommandResponse defines model for RaybotCommandResponse.
type RaybotCommandResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// RaybotId The id of the resource, in UUID format
	RaybotId    string              `json:"raybotId"`
	Type        RaybotCommandType   `json:"type"`
	Status      RaybotCommandStatus `json:"status"`
	Inputs      json.RawMessage     `json:"inputs"`
	Outputs     json.RawMessage     `json:"outputs"`
	Error       *string             `json:"error"`
	CreatedAt   time.Time           `json:"createdAt"`
	UpdatedAt   time.Time           `json:"updatedAt"`
	CompletedAt *time.Time          `json:"completedAt"`
}

// RaybotCommandStatus defines model for RaybotCommandStatus.
type RaybotCommandStatus = string

// RaybotCommandType defines model for RaybotCommandType.
type RaybotCommandType = string

// RaybotCommandsListResponse defines model for RaybotCommandsListResponse.
type RaybotCommandsListResponse struct {
	Items      []RaybotCommandResponse `json:"items"`
	TotalItems int64                   `json:"totalItems"`
}

// RaybotResponse defines model for RaybotResponse.
type RaybotResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// Name The name of the raybot.
	Name        string      `json:"name"`
	ControlMode ControlMode `json:"controlMode"`

	// IsOnline The online status of the raybot.
	IsOnline bool `json:"isOnline"`

	// IpAddress The IP address of the raybot.
	IpAddress *string `json:"ipAddress"`

	// LastConnectedAt The last time the raybot was connected.
	LastConnectedAt *time.Time `json:"lastConnectedAt"`

	// CreatedAt The time the raybot was created.
	CreatedAt time.Time `json:"createdAt"`

	// UpdatedAt The time the raybot was last updated.
	UpdatedAt time.Time `json:"updatedAt"`
}

// RaybotsListResponse defines model for RaybotsListResponse.
type RaybotsListResponse struct {
	Items      []RaybotResponse `json:"items"`
	TotalItems int64            `json:"totalItems"`
}

// RunWorkflowRequest defines model for RunWorkflowRequest.
type RunWorkflowRequest struct {
	// RuntimeVariables The runtime variables of the workflow.
	RuntimeVariables map[string]any `json:"runtimeVariables"`
}

// RunWorkflowResponse defines model for RunWorkflowResponse.
type RunWorkflowResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`
}

// StepExecutionResponse defines model for StepExecutionResponse.
type StepExecutionResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// WorkflowExecutionId The id of the resource, in UUID format
	WorkflowExecutionId string              `json:"workflowExecutionId"`
	Node                json.RawMessage     `json:"node"`
	Inputs              map[string]any      `json:"inputs"`
	Outputs             map[string]any      `json:"outputs"`
	Error               *string             `json:"error"`
	CreatedAt           time.Time           `json:"createdAt"`
	UpdatedAt           time.Time           `json:"updatedAt"`
	StartedAt           *time.Time          `json:"startedAt"`
	CompletedAt         *time.Time          `json:"completedAt"`
	Status              StepExecutionStatus `json:"status"`
}

// StepExecutionStatus defines model for StepExecutionStatus.
type StepExecutionStatus = string

// UpdateQRLocationRequest defines model for UpdateQRLocationRequest.
type UpdateQRLocationRequest struct {
	// Metadata The metadata of the location.
	Metadata map[string]any `json:"metadata"`

	// Name The name of the location.
	Name string `json:"name"`

	// QrCode The QR code of the location.
	QrCode string `json:"qrCode"`
}

// UpdateWorkflowRequest defines model for UpdateWorkflowRequest.
type UpdateWorkflowRequest struct {
	// Name The name of the workflow.
	Name string `json:"name"`

	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// Data The data of the workflow.
	Data json.RawMessage `json:"data"`
}

// ViewPort defines model for ViewPort.
type ViewPort struct {
	X    float32 `json:"x"`
	Y    float32 `json:"y"`
	Zoom float32 `json:"zoom"`
}

// WorkflowData defines model for WorkflowData.
type WorkflowData struct {
	Edges    *[]WorkflowEdge `json:"edges,omitempty"`
	Nodes    *[]WorkflowNode `json:"nodes,omitempty"`
	Position *[]float32      `json:"position,omitempty"`
	Viewport *ViewPort       `json:"viewport,omitempty"`
	Zoom     *float32        `json:"zoom,omitempty"`
}

// WorkflowEdge defines model for WorkflowEdge.
type WorkflowEdge struct {
	Id           openapi_types.UUID `json:"id"`
	Type         string             `json:"type"`
	Source       string             `json:"source"`
	Target       string             `json:"target"`
	SourceHandle string             `json:"sourceHandle"`
	TargetHandle string             `json:"targetHandle"`
	Label        string             `json:"label"`
	Animated     bool               `json:"animated"`
	SourceX      float32            `json:"sourceX"`
	SourceY      float32            `json:"sourceY"`
	TargetX      float32            `json:"targetX"`
	TargetY      float32            `json:"targetY"`
}

// WorkflowExecutionResponse defines model for WorkflowExecutionResponse.
type WorkflowExecutionResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// WorkflowId The id of the resource, in UUID format
	WorkflowId  string                  `json:"workflowId"`
	Status      WorkflowExecutionStatus `json:"status"`
	Data        json.RawMessage         `json:"data"`
	Inputs      map[string]any          `json:"inputs"`
	Outputs     map[string]any          `json:"outputs"`
	Error       *string                 `json:"error"`
	CreatedAt   time.Time               `json:"createdAt"`
	UpdatedAt   time.Time               `json:"updatedAt"`
	StartedAt   *time.Time              `json:"startedAt"`
	CompletedAt *time.Time              `json:"completedAt"`
}

// WorkflowExecutionStatus defines model for WorkflowExecutionStatus.
type WorkflowExecutionStatus = string

// WorkflowExecutionsListResponse defines model for WorkflowExecutionsListResponse.
type WorkflowExecutionsListResponse struct {
	Items      []WorkflowExecutionResponse `json:"items"`
	TotalItems int64                       `json:"totalItems"`
}

// WorkflowItemListResponse defines model for WorkflowItemListResponse.
type WorkflowItemListResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// IsDraft The draft status of the workflow.
	IsDraft bool `json:"isDraft"`

	// CreatedAt The creation date of the workflow.
	CreatedAt time.Time `json:"createdAt"`

	// UpdatedAt The last update date of the workflow.
	UpdatedAt time.Time `json:"updatedAt"`
}

// WorkflowNode defines model for WorkflowNode.
type WorkflowNode struct {
	// Id The unique identifier of the node.
	Id       openapi_types.UUID `json:"id"`
	Type     NodeType           `json:"type"`
	Position Position           `json:"position"`

	// Label The label of the node.
	Label string `json:"label"`

	// Data The data of the node.
	Data json.RawMessage `json:"data"`
}

// WorkflowResponse defines model for WorkflowResponse.
type WorkflowResponse struct {
	// Id The id of the resource, in UUID format
	Id string `json:"id"`

	// Name The name of the workflow.
	Name string `json:"name"`

	// Description The description of the workflow.
	Description *string `json:"description,omitempty"`

	// IsDraft The draft status of the workflow.
	IsDraft bool            `json:"isDraft"`
	Data    json.RawMessage `json:"data"`

	// CreatedAt The creation date of the workflow.
	CreatedAt time.Time `json:"createdAt"`

	// UpdatedAt The last update date of the workflow.
	UpdatedAt time.Time `json:"updatedAt"`
}

// WorkflowsListResponse defines model for WorkflowsListResponse.
type WorkflowsListResponse struct {
	// TotalItems The total number of items.
	TotalItems int64                      `json:"totalItems"`
	Items      []WorkflowItemListResponse `json:"items"`
}

// Page defines model for Page.
type Page = uint

// PageSize defines model for PageSize.
type PageSize = uint

// QrLocationListParams defines parameters for QrLocationList.
type QrLocationListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort the results by one or more columns.
	//   - Use a column name for ascending order (e.g., created_at).
	//   - Prefix with `-` for descending order (e.g., -created_at).
	//
	// Allowed columns: `name`, `qr_code`, `created_at`, `updated_at`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// RaybotListParams defines parameters for RaybotList.
type RaybotListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort the results by one or more columns.
	//   - Use a column name for ascending order (e.g., created_at).
	//   - Prefix with `-` for descending order (e.g., -created_at).
	//   - Separate multiple columns with a comma (e.g., created_at,-updated_at).
	//
	// Allowed columns: `name`, `control_mode`, `is_online`, `ip_address`, `last_connected_at`, `created_at`, `updated_at`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// IsOnline Filter by raybot online status.
	IsOnline *bool `form:"isOnline,omitempty" json:"isOnline,omitempty"`

	// ControlMode Filter by raybot control mode.
	// Allowed values: `MANUAL`, `AUTO`.
	ControlMode *string `form:"controlMode,omitempty" json:"controlMode,omitempty"`
}

// RaybotCommandListParams defines parameters for RaybotCommandList.
type RaybotCommandListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort the results by one or more columns.
	//   - Use a column name for ascending order (e.g., created_at).
	//   - Prefix with `-` for descending order (e.g., -created_at).
	//   - Separate multiple columns with a comma (e.g., created_at,-updated_at).
	//
	// Allowed columns: `type`, `status`, `completed_at`, `created_at`, `updated_at`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// WorkflowListParams defines parameters for WorkflowList.
type WorkflowListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort the results by one or more columns.
	//   - Use a column name for ascending order (e.g., created_at).
	//   - Prefix with `-` for descending order (e.g., -created_at).
	//   - Separate multiple columns with a comma (e.g., created_at,-updated_at).
	//
	// Allowed columns: `name`, `is_draft`, `created_at`, `updated_at`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// IsDraft Filter by draft status
	IsDraft *bool `form:"isDraft,omitempty" json:"isDraft,omitempty"`
}

// WorkflowExecutionListParams defines parameters for WorkflowExecutionList.
type WorkflowExecutionListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize The number of items per page
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Sort the results by one or more columns.
	//   - Use a column name for ascending order (e.g., created_at).
	//   - Prefix with `-` for descending order (e.g., -created_at).
	//   - Separate multiple columns with a comma (e.g., created_at,-updated_at).
	//
	// Allowed columns: `status`, `started_at`, `completed_at`, `created_at`, `updated_at`.
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`
}

// QrLocationCreateJSONRequestBody defines body for QrLocationCreate for application/json ContentType.
type QrLocationCreateJSONRequestBody = CreateQRLocationRequest

// QrLocationUpdateJSONRequestBody defines body for QrLocationUpdate for application/json ContentType.
type QrLocationUpdateJSONRequestBody = UpdateQRLocationRequest

// RaybotCreateJSONRequestBody defines body for RaybotCreate for application/json ContentType.
type RaybotCreateJSONRequestBody = CreateRaybotRequest

// RaybotCommandCreateJSONRequestBody defines body for RaybotCommandCreate for application/json ContentType.
type RaybotCommandCreateJSONRequestBody = CreateRaybotCommandRequest

// WorkflowCreateJSONRequestBody defines body for WorkflowCreate for application/json ContentType.
type WorkflowCreateJSONRequestBody = CreateWorkflowRequest

// WorkflowUpdateJSONRequestBody defines body for WorkflowUpdate for application/json ContentType.
type WorkflowUpdateJSONRequestBody = UpdateWorkflowRequest

// WorkflowRunJSONRequestBody defines body for WorkflowRun for application/json ContentType.
type WorkflowRunJSONRequestBody = RunWorkflowRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List QR locations
	// (GET /qr-locations)
	QrLocationList(w http.ResponseWriter, r *http.Request, params QrLocationListParams)
	// Create QR location
	// (POST /qr-locations)
	QrLocationCreate(w http.ResponseWriter, r *http.Request)
	// Delete QR location by id
	// (DELETE /qr-locations/{qrLocationId})
	QrLocationDelete(w http.ResponseWriter, r *http.Request, qrLocationId string)
	// Get QR location by id
	// (GET /qr-locations/{qrLocationId})
	QrLocationGet(w http.ResponseWriter, r *http.Request, qrLocationId string)
	// Update QR location by id
	// (PUT /qr-locations/{qrLocationId})
	QrLocationUpdate(w http.ResponseWriter, r *http.Request, qrLocationId string)
	// Get raybot command by id
	// (GET /raybot-commands/{raybotCommandId})
	RaybotCommandGet(w http.ResponseWriter, r *http.Request, raybotCommandId string)
	// List raybots
	// (GET /raybots)
	RaybotList(w http.ResponseWriter, r *http.Request, params RaybotListParams)
	// Create raybot
	// (POST /raybots)
	RaybotCreate(w http.ResponseWriter, r *http.Request)
	// Delete raybot by id
	// (DELETE /raybots/{raybotId})
	RaybotDelete(w http.ResponseWriter, r *http.Request, raybotId string)
	// Get raybot by id
	// (GET /raybots/{raybotId})
	RaybotGet(w http.ResponseWriter, r *http.Request, raybotId string)
	// List raybot commands
	// (GET /raybots/{raybotId}/commands)
	RaybotCommandList(w http.ResponseWriter, r *http.Request, raybotId string, params RaybotCommandListParams)
	// Create raybot command
	// (POST /raybots/{raybotId}/commands)
	RaybotCommandCreate(w http.ResponseWriter, r *http.Request, raybotId string)
	// Get step by id
	// (GET /step-executions/{stepExecutionId})
	StepExecutionGet(w http.ResponseWriter, r *http.Request, stepExecutionId string)
	// Get workflow execution by id
	// (GET /workflow-executions/{workflowExecutionId})
	WorkflowExecutionGet(w http.ResponseWriter, r *http.Request, workflowExecutionId string)
	// List steps by workflow execution id
	// (GET /workflow-executions/{workflowExecutionId}/steps)
	StepExecutionListByWorkflowExecutionId(w http.ResponseWriter, r *http.Request, workflowExecutionId string)
	// List  workflows
	// (GET /workflows)
	WorkflowList(w http.ResponseWriter, r *http.Request, params WorkflowListParams)
	// Create workflow
	// (POST /workflows)
	WorkflowCreate(w http.ResponseWriter, r *http.Request)
	// Delete workflow by id
	// (DELETE /workflows/{workflowId})
	WorkflowDelete(w http.ResponseWriter, r *http.Request, workflowId string)
	// Get workflow by id
	// (GET /workflows/{workflowId})
	WorkflowGet(w http.ResponseWriter, r *http.Request, workflowId string)
	// Update workflow by id
	// (PUT /workflows/{workflowId})
	WorkflowUpdate(w http.ResponseWriter, r *http.Request, workflowId string)
	// List workflow executions by workflow id
	// (GET /workflows/{workflowId}/executions)
	WorkflowExecutionList(w http.ResponseWriter, r *http.Request, workflowId string, params WorkflowExecutionListParams)
	// Run workflow by id
	// (POST /workflows/{workflowId}/run)
	WorkflowRun(w http.ResponseWriter, r *http.Request, workflowId string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List QR locations
// (GET /qr-locations)
func (_ Unimplemented) QrLocationList(w http.ResponseWriter, r *http.Request, params QrLocationListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create QR location
// (POST /qr-locations)
func (_ Unimplemented) QrLocationCreate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete QR location by id
// (DELETE /qr-locations/{qrLocationId})
func (_ Unimplemented) QrLocationDelete(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get QR location by id
// (GET /qr-locations/{qrLocationId})
func (_ Unimplemented) QrLocationGet(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update QR location by id
// (PUT /qr-locations/{qrLocationId})
func (_ Unimplemented) QrLocationUpdate(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get raybot command by id
// (GET /raybot-commands/{raybotCommandId})
func (_ Unimplemented) RaybotCommandGet(w http.ResponseWriter, r *http.Request, raybotCommandId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List raybots
// (GET /raybots)
func (_ Unimplemented) RaybotList(w http.ResponseWriter, r *http.Request, params RaybotListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create raybot
// (POST /raybots)
func (_ Unimplemented) RaybotCreate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete raybot by id
// (DELETE /raybots/{raybotId})
func (_ Unimplemented) RaybotDelete(w http.ResponseWriter, r *http.Request, raybotId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get raybot by id
// (GET /raybots/{raybotId})
func (_ Unimplemented) RaybotGet(w http.ResponseWriter, r *http.Request, raybotId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List raybot commands
// (GET /raybots/{raybotId}/commands)
func (_ Unimplemented) RaybotCommandList(w http.ResponseWriter, r *http.Request, raybotId string, params RaybotCommandListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create raybot command
// (POST /raybots/{raybotId}/commands)
func (_ Unimplemented) RaybotCommandCreate(w http.ResponseWriter, r *http.Request, raybotId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get step by id
// (GET /step-executions/{stepExecutionId})
func (_ Unimplemented) StepExecutionGet(w http.ResponseWriter, r *http.Request, stepExecutionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get workflow execution by id
// (GET /workflow-executions/{workflowExecutionId})
func (_ Unimplemented) WorkflowExecutionGet(w http.ResponseWriter, r *http.Request, workflowExecutionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List steps by workflow execution id
// (GET /workflow-executions/{workflowExecutionId}/steps)
func (_ Unimplemented) StepExecutionListByWorkflowExecutionId(w http.ResponseWriter, r *http.Request, workflowExecutionId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List  workflows
// (GET /workflows)
func (_ Unimplemented) WorkflowList(w http.ResponseWriter, r *http.Request, params WorkflowListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create workflow
// (POST /workflows)
func (_ Unimplemented) WorkflowCreate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete workflow by id
// (DELETE /workflows/{workflowId})
func (_ Unimplemented) WorkflowDelete(w http.ResponseWriter, r *http.Request, workflowId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get workflow by id
// (GET /workflows/{workflowId})
func (_ Unimplemented) WorkflowGet(w http.ResponseWriter, r *http.Request, workflowId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update workflow by id
// (PUT /workflows/{workflowId})
func (_ Unimplemented) WorkflowUpdate(w http.ResponseWriter, r *http.Request, workflowId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List workflow executions by workflow id
// (GET /workflows/{workflowId}/executions)
func (_ Unimplemented) WorkflowExecutionList(w http.ResponseWriter, r *http.Request, workflowId string, params WorkflowExecutionListParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Run workflow by id
// (POST /workflows/{workflowId}/run)
func (_ Unimplemented) WorkflowRun(w http.ResponseWriter, r *http.Request, workflowId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// QrLocationList operation middleware
func (siw *ServerInterfaceWrapper) QrLocationList(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params QrLocationListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QrLocationList(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// QrLocationCreate operation middleware
func (siw *ServerInterfaceWrapper) QrLocationCreate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QrLocationCreate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// QrLocationDelete operation middleware
func (siw *ServerInterfaceWrapper) QrLocationDelete(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "qrLocationId" -------------
	var qrLocationId string

	err = runtime.BindStyledParameterWithOptions("simple", "qrLocationId", chi.URLParam(r, "qrLocationId"), &qrLocationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qrLocationId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QrLocationDelete(w, r, qrLocationId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// QrLocationGet operation middleware
func (siw *ServerInterfaceWrapper) QrLocationGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "qrLocationId" -------------
	var qrLocationId string

	err = runtime.BindStyledParameterWithOptions("simple", "qrLocationId", chi.URLParam(r, "qrLocationId"), &qrLocationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qrLocationId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QrLocationGet(w, r, qrLocationId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// QrLocationUpdate operation middleware
func (siw *ServerInterfaceWrapper) QrLocationUpdate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "qrLocationId" -------------
	var qrLocationId string

	err = runtime.BindStyledParameterWithOptions("simple", "qrLocationId", chi.URLParam(r, "qrLocationId"), &qrLocationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qrLocationId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QrLocationUpdate(w, r, qrLocationId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotCommandGet operation middleware
func (siw *ServerInterfaceWrapper) RaybotCommandGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "raybotCommandId" -------------
	var raybotCommandId string

	err = runtime.BindStyledParameterWithOptions("simple", "raybotCommandId", chi.URLParam(r, "raybotCommandId"), &raybotCommandId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "raybotCommandId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotCommandGet(w, r, raybotCommandId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotList operation middleware
func (siw *ServerInterfaceWrapper) RaybotList(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RaybotListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "isOnline" -------------

	err = runtime.BindQueryParameter("form", true, false, "isOnline", r.URL.Query(), &params.IsOnline)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "isOnline", Err: err})
		return
	}

	// ------------- Optional query parameter "controlMode" -------------

	err = runtime.BindQueryParameter("form", true, false, "controlMode", r.URL.Query(), &params.ControlMode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "controlMode", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotList(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotCreate operation middleware
func (siw *ServerInterfaceWrapper) RaybotCreate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotCreate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotDelete operation middleware
func (siw *ServerInterfaceWrapper) RaybotDelete(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "raybotId" -------------
	var raybotId string

	err = runtime.BindStyledParameterWithOptions("simple", "raybotId", chi.URLParam(r, "raybotId"), &raybotId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "raybotId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotDelete(w, r, raybotId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotGet operation middleware
func (siw *ServerInterfaceWrapper) RaybotGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "raybotId" -------------
	var raybotId string

	err = runtime.BindStyledParameterWithOptions("simple", "raybotId", chi.URLParam(r, "raybotId"), &raybotId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "raybotId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotGet(w, r, raybotId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotCommandList operation middleware
func (siw *ServerInterfaceWrapper) RaybotCommandList(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "raybotId" -------------
	var raybotId string

	err = runtime.BindStyledParameterWithOptions("simple", "raybotId", chi.URLParam(r, "raybotId"), &raybotId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "raybotId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params RaybotCommandListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotCommandList(w, r, raybotId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RaybotCommandCreate operation middleware
func (siw *ServerInterfaceWrapper) RaybotCommandCreate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "raybotId" -------------
	var raybotId string

	err = runtime.BindStyledParameterWithOptions("simple", "raybotId", chi.URLParam(r, "raybotId"), &raybotId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "raybotId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RaybotCommandCreate(w, r, raybotId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StepExecutionGet operation middleware
func (siw *ServerInterfaceWrapper) StepExecutionGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "stepExecutionId" -------------
	var stepExecutionId string

	err = runtime.BindStyledParameterWithOptions("simple", "stepExecutionId", chi.URLParam(r, "stepExecutionId"), &stepExecutionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "stepExecutionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StepExecutionGet(w, r, stepExecutionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowExecutionGet operation middleware
func (siw *ServerInterfaceWrapper) WorkflowExecutionGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowExecutionId" -------------
	var workflowExecutionId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowExecutionId", chi.URLParam(r, "workflowExecutionId"), &workflowExecutionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowExecutionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowExecutionGet(w, r, workflowExecutionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// StepExecutionListByWorkflowExecutionId operation middleware
func (siw *ServerInterfaceWrapper) StepExecutionListByWorkflowExecutionId(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowExecutionId" -------------
	var workflowExecutionId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowExecutionId", chi.URLParam(r, "workflowExecutionId"), &workflowExecutionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowExecutionId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StepExecutionListByWorkflowExecutionId(w, r, workflowExecutionId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowList operation middleware
func (siw *ServerInterfaceWrapper) WorkflowList(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params WorkflowListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "isDraft" -------------

	err = runtime.BindQueryParameter("form", true, false, "isDraft", r.URL.Query(), &params.IsDraft)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "isDraft", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowList(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowCreate operation middleware
func (siw *ServerInterfaceWrapper) WorkflowCreate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowCreate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowDelete operation middleware
func (siw *ServerInterfaceWrapper) WorkflowDelete(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowId" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowId", chi.URLParam(r, "workflowId"), &workflowId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowDelete(w, r, workflowId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowGet operation middleware
func (siw *ServerInterfaceWrapper) WorkflowGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowId" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowId", chi.URLParam(r, "workflowId"), &workflowId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowGet(w, r, workflowId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowUpdate operation middleware
func (siw *ServerInterfaceWrapper) WorkflowUpdate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowId" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowId", chi.URLParam(r, "workflowId"), &workflowId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowUpdate(w, r, workflowId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowExecutionList operation middleware
func (siw *ServerInterfaceWrapper) WorkflowExecutionList(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowId" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowId", chi.URLParam(r, "workflowId"), &workflowId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params WorkflowExecutionListParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pageSize", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowExecutionList(w, r, workflowId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WorkflowRun operation middleware
func (siw *ServerInterfaceWrapper) WorkflowRun(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "workflowId" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithOptions("simple", "workflowId", chi.URLParam(r, "workflowId"), &workflowId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "workflowId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WorkflowRun(w, r, workflowId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/qr-locations", wrapper.QrLocationList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/qr-locations", wrapper.QrLocationCreate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/qr-locations/{qrLocationId}", wrapper.QrLocationDelete)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/qr-locations/{qrLocationId}", wrapper.QrLocationGet)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/qr-locations/{qrLocationId}", wrapper.QrLocationUpdate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/raybot-commands/{raybotCommandId}", wrapper.RaybotCommandGet)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/raybots", wrapper.RaybotList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/raybots", wrapper.RaybotCreate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/raybots/{raybotId}", wrapper.RaybotDelete)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/raybots/{raybotId}", wrapper.RaybotGet)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/raybots/{raybotId}/commands", wrapper.RaybotCommandList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/raybots/{raybotId}/commands", wrapper.RaybotCommandCreate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/step-executions/{stepExecutionId}", wrapper.StepExecutionGet)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflow-executions/{workflowExecutionId}", wrapper.WorkflowExecutionGet)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflow-executions/{workflowExecutionId}/steps", wrapper.StepExecutionListByWorkflowExecutionId)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflows", wrapper.WorkflowList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workflows", wrapper.WorkflowCreate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/workflows/{workflowId}", wrapper.WorkflowDelete)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflows/{workflowId}", wrapper.WorkflowGet)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/workflows/{workflowId}", wrapper.WorkflowUpdate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/workflows/{workflowId}/executions", wrapper.WorkflowExecutionList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/workflows/{workflowId}/run", wrapper.WorkflowRun)
	})

	return r
}

type QrLocationListRequestObject struct {
	Params QrLocationListParams
}

type QrLocationListResponseObject interface {
	VisitQrLocationListResponse(w http.ResponseWriter) error
}

type QrLocationList200JSONResponse QRLocationsListResponse

func (response QrLocationList200JSONResponse) VisitQrLocationListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationList400JSONResponse ErrorResponse

func (response QrLocationList400JSONResponse) VisitQrLocationListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationCreateRequestObject struct {
	Body *QrLocationCreateJSONRequestBody
}

type QrLocationCreateResponseObject interface {
	VisitQrLocationCreateResponse(w http.ResponseWriter) error
}

type QrLocationCreate201JSONResponse QRLocationResponse

func (response QrLocationCreate201JSONResponse) VisitQrLocationCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationCreate400JSONResponse ErrorResponse

func (response QrLocationCreate400JSONResponse) VisitQrLocationCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationDeleteRequestObject struct {
	QrLocationId string `json:"qrLocationId"`
}

type QrLocationDeleteResponseObject interface {
	VisitQrLocationDeleteResponse(w http.ResponseWriter) error
}

type QrLocationDelete204Response struct {
}

func (response QrLocationDelete204Response) VisitQrLocationDeleteResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type QrLocationDelete404JSONResponse ErrorResponse

func (response QrLocationDelete404JSONResponse) VisitQrLocationDeleteResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationGetRequestObject struct {
	QrLocationId string `json:"qrLocationId"`
}

type QrLocationGetResponseObject interface {
	VisitQrLocationGetResponse(w http.ResponseWriter) error
}

type QrLocationGet200JSONResponse QRLocationResponse

func (response QrLocationGet200JSONResponse) VisitQrLocationGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationGet404JSONResponse ErrorResponse

func (response QrLocationGet404JSONResponse) VisitQrLocationGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationUpdateRequestObject struct {
	QrLocationId string `json:"qrLocationId"`
	Body         *QrLocationUpdateJSONRequestBody
}

type QrLocationUpdateResponseObject interface {
	VisitQrLocationUpdateResponse(w http.ResponseWriter) error
}

type QrLocationUpdate200JSONResponse QRLocationResponse

func (response QrLocationUpdate200JSONResponse) VisitQrLocationUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationUpdate400JSONResponse ErrorResponse

func (response QrLocationUpdate400JSONResponse) VisitQrLocationUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type QrLocationUpdate404JSONResponse ErrorResponse

func (response QrLocationUpdate404JSONResponse) VisitQrLocationUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandGetRequestObject struct {
	RaybotCommandId string `json:"raybotCommandId"`
}

type RaybotCommandGetResponseObject interface {
	VisitRaybotCommandGetResponse(w http.ResponseWriter) error
}

type RaybotCommandGet200JSONResponse RaybotCommandResponse

func (response RaybotCommandGet200JSONResponse) VisitRaybotCommandGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandGet404JSONResponse ErrorResponse

func (response RaybotCommandGet404JSONResponse) VisitRaybotCommandGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RaybotListRequestObject struct {
	Params RaybotListParams
}

type RaybotListResponseObject interface {
	VisitRaybotListResponse(w http.ResponseWriter) error
}

type RaybotList200JSONResponse RaybotsListResponse

func (response RaybotList200JSONResponse) VisitRaybotListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RaybotList400JSONResponse ErrorResponse

func (response RaybotList400JSONResponse) VisitRaybotListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCreateRequestObject struct {
	Body *RaybotCreateJSONRequestBody
}

type RaybotCreateResponseObject interface {
	VisitRaybotCreateResponse(w http.ResponseWriter) error
}

type RaybotCreate201JSONResponse RaybotResponse

func (response RaybotCreate201JSONResponse) VisitRaybotCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCreate400JSONResponse ErrorResponse

func (response RaybotCreate400JSONResponse) VisitRaybotCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCreate409JSONResponse ErrorResponse

func (response RaybotCreate409JSONResponse) VisitRaybotCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(409)

	return json.NewEncoder(w).Encode(response)
}

type RaybotDeleteRequestObject struct {
	RaybotId string `json:"raybotId"`
}

type RaybotDeleteResponseObject interface {
	VisitRaybotDeleteResponse(w http.ResponseWriter) error
}

type RaybotDelete204Response struct {
}

func (response RaybotDelete204Response) VisitRaybotDeleteResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RaybotDelete404JSONResponse ErrorResponse

func (response RaybotDelete404JSONResponse) VisitRaybotDeleteResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RaybotGetRequestObject struct {
	RaybotId string `json:"raybotId"`
}

type RaybotGetResponseObject interface {
	VisitRaybotGetResponse(w http.ResponseWriter) error
}

type RaybotGet200JSONResponse RaybotResponse

func (response RaybotGet200JSONResponse) VisitRaybotGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RaybotGet404JSONResponse ErrorResponse

func (response RaybotGet404JSONResponse) VisitRaybotGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandListRequestObject struct {
	RaybotId string `json:"raybotId"`
	Params   RaybotCommandListParams
}

type RaybotCommandListResponseObject interface {
	VisitRaybotCommandListResponse(w http.ResponseWriter) error
}

type RaybotCommandList200JSONResponse RaybotCommandsListResponse

func (response RaybotCommandList200JSONResponse) VisitRaybotCommandListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandList400JSONResponse ErrorResponse

func (response RaybotCommandList400JSONResponse) VisitRaybotCommandListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandCreateRequestObject struct {
	RaybotId string `json:"raybotId"`
	Body     *RaybotCommandCreateJSONRequestBody
}

type RaybotCommandCreateResponseObject interface {
	VisitRaybotCommandCreateResponse(w http.ResponseWriter) error
}

type RaybotCommandCreate201JSONResponse RaybotCommandResponse

func (response RaybotCommandCreate201JSONResponse) VisitRaybotCommandCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type RaybotCommandCreate400JSONResponse ErrorResponse

func (response RaybotCommandCreate400JSONResponse) VisitRaybotCommandCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type StepExecutionGetRequestObject struct {
	StepExecutionId string `json:"stepExecutionId"`
}

type StepExecutionGetResponseObject interface {
	VisitStepExecutionGetResponse(w http.ResponseWriter) error
}

type StepExecutionGet200JSONResponse StepExecutionResponse

func (response StepExecutionGet200JSONResponse) VisitStepExecutionGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type StepExecutionGet404JSONResponse ErrorResponse

func (response StepExecutionGet404JSONResponse) VisitStepExecutionGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowExecutionGetRequestObject struct {
	WorkflowExecutionId string `json:"workflowExecutionId"`
}

type WorkflowExecutionGetResponseObject interface {
	VisitWorkflowExecutionGetResponse(w http.ResponseWriter) error
}

type WorkflowExecutionGet200JSONResponse WorkflowExecutionResponse

func (response WorkflowExecutionGet200JSONResponse) VisitWorkflowExecutionGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowExecutionGet404JSONResponse ErrorResponse

func (response WorkflowExecutionGet404JSONResponse) VisitWorkflowExecutionGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type StepExecutionListByWorkflowExecutionIdRequestObject struct {
	WorkflowExecutionId string `json:"workflowExecutionId"`
}

type StepExecutionListByWorkflowExecutionIdResponseObject interface {
	VisitStepExecutionListByWorkflowExecutionIdResponse(w http.ResponseWriter) error
}

type StepExecutionListByWorkflowExecutionId200JSONResponse []StepExecutionResponse

func (response StepExecutionListByWorkflowExecutionId200JSONResponse) VisitStepExecutionListByWorkflowExecutionIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type StepExecutionListByWorkflowExecutionId400JSONResponse ErrorResponse

func (response StepExecutionListByWorkflowExecutionId400JSONResponse) VisitStepExecutionListByWorkflowExecutionIdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowListRequestObject struct {
	Params WorkflowListParams
}

type WorkflowListResponseObject interface {
	VisitWorkflowListResponse(w http.ResponseWriter) error
}

type WorkflowList200JSONResponse WorkflowsListResponse

func (response WorkflowList200JSONResponse) VisitWorkflowListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowList400JSONResponse ErrorResponse

func (response WorkflowList400JSONResponse) VisitWorkflowListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowCreateRequestObject struct {
	Body *WorkflowCreateJSONRequestBody
}

type WorkflowCreateResponseObject interface {
	VisitWorkflowCreateResponse(w http.ResponseWriter) error
}

type WorkflowCreate201JSONResponse WorkflowResponse

func (response WorkflowCreate201JSONResponse) VisitWorkflowCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowCreate400JSONResponse ErrorResponse

func (response WorkflowCreate400JSONResponse) VisitWorkflowCreateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowDeleteRequestObject struct {
	WorkflowId string `json:"workflowId"`
}

type WorkflowDeleteResponseObject interface {
	VisitWorkflowDeleteResponse(w http.ResponseWriter) error
}

type WorkflowDelete204Response struct {
}

func (response WorkflowDelete204Response) VisitWorkflowDeleteResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type WorkflowDelete404JSONResponse ErrorResponse

func (response WorkflowDelete404JSONResponse) VisitWorkflowDeleteResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowGetRequestObject struct {
	WorkflowId string `json:"workflowId"`
}

type WorkflowGetResponseObject interface {
	VisitWorkflowGetResponse(w http.ResponseWriter) error
}

type WorkflowGet200JSONResponse WorkflowResponse

func (response WorkflowGet200JSONResponse) VisitWorkflowGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowGet404JSONResponse ErrorResponse

func (response WorkflowGet404JSONResponse) VisitWorkflowGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowUpdateRequestObject struct {
	WorkflowId string `json:"workflowId"`
	Body       *WorkflowUpdateJSONRequestBody
}

type WorkflowUpdateResponseObject interface {
	VisitWorkflowUpdateResponse(w http.ResponseWriter) error
}

type WorkflowUpdate200JSONResponse WorkflowResponse

func (response WorkflowUpdate200JSONResponse) VisitWorkflowUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowUpdate400JSONResponse ErrorResponse

func (response WorkflowUpdate400JSONResponse) VisitWorkflowUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowExecutionListRequestObject struct {
	WorkflowId string `json:"workflowId"`
	Params     WorkflowExecutionListParams
}

type WorkflowExecutionListResponseObject interface {
	VisitWorkflowExecutionListResponse(w http.ResponseWriter) error
}

type WorkflowExecutionList200JSONResponse WorkflowExecutionsListResponse

func (response WorkflowExecutionList200JSONResponse) VisitWorkflowExecutionListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowExecutionList400JSONResponse ErrorResponse

func (response WorkflowExecutionList400JSONResponse) VisitWorkflowExecutionListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowRunRequestObject struct {
	WorkflowId string `json:"workflowId"`
	Body       *WorkflowRunJSONRequestBody
}

type WorkflowRunResponseObject interface {
	VisitWorkflowRunResponse(w http.ResponseWriter) error
}

type WorkflowRun201JSONResponse RunWorkflowResponse

func (response WorkflowRun201JSONResponse) VisitWorkflowRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type WorkflowRun400JSONResponse ErrorResponse

func (response WorkflowRun400JSONResponse) VisitWorkflowRunResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List QR locations
	// (GET /qr-locations)
	QrLocationList(ctx context.Context, request QrLocationListRequestObject) (QrLocationListResponseObject, error)
	// Create QR location
	// (POST /qr-locations)
	QrLocationCreate(ctx context.Context, request QrLocationCreateRequestObject) (QrLocationCreateResponseObject, error)
	// Delete QR location by id
	// (DELETE /qr-locations/{qrLocationId})
	QrLocationDelete(ctx context.Context, request QrLocationDeleteRequestObject) (QrLocationDeleteResponseObject, error)
	// Get QR location by id
	// (GET /qr-locations/{qrLocationId})
	QrLocationGet(ctx context.Context, request QrLocationGetRequestObject) (QrLocationGetResponseObject, error)
	// Update QR location by id
	// (PUT /qr-locations/{qrLocationId})
	QrLocationUpdate(ctx context.Context, request QrLocationUpdateRequestObject) (QrLocationUpdateResponseObject, error)
	// Get raybot command by id
	// (GET /raybot-commands/{raybotCommandId})
	RaybotCommandGet(ctx context.Context, request RaybotCommandGetRequestObject) (RaybotCommandGetResponseObject, error)
	// List raybots
	// (GET /raybots)
	RaybotList(ctx context.Context, request RaybotListRequestObject) (RaybotListResponseObject, error)
	// Create raybot
	// (POST /raybots)
	RaybotCreate(ctx context.Context, request RaybotCreateRequestObject) (RaybotCreateResponseObject, error)
	// Delete raybot by id
	// (DELETE /raybots/{raybotId})
	RaybotDelete(ctx context.Context, request RaybotDeleteRequestObject) (RaybotDeleteResponseObject, error)
	// Get raybot by id
	// (GET /raybots/{raybotId})
	RaybotGet(ctx context.Context, request RaybotGetRequestObject) (RaybotGetResponseObject, error)
	// List raybot commands
	// (GET /raybots/{raybotId}/commands)
	RaybotCommandList(ctx context.Context, request RaybotCommandListRequestObject) (RaybotCommandListResponseObject, error)
	// Create raybot command
	// (POST /raybots/{raybotId}/commands)
	RaybotCommandCreate(ctx context.Context, request RaybotCommandCreateRequestObject) (RaybotCommandCreateResponseObject, error)
	// Get step by id
	// (GET /step-executions/{stepExecutionId})
	StepExecutionGet(ctx context.Context, request StepExecutionGetRequestObject) (StepExecutionGetResponseObject, error)
	// Get workflow execution by id
	// (GET /workflow-executions/{workflowExecutionId})
	WorkflowExecutionGet(ctx context.Context, request WorkflowExecutionGetRequestObject) (WorkflowExecutionGetResponseObject, error)
	// List steps by workflow execution id
	// (GET /workflow-executions/{workflowExecutionId}/steps)
	StepExecutionListByWorkflowExecutionId(ctx context.Context, request StepExecutionListByWorkflowExecutionIdRequestObject) (StepExecutionListByWorkflowExecutionIdResponseObject, error)
	// List  workflows
	// (GET /workflows)
	WorkflowList(ctx context.Context, request WorkflowListRequestObject) (WorkflowListResponseObject, error)
	// Create workflow
	// (POST /workflows)
	WorkflowCreate(ctx context.Context, request WorkflowCreateRequestObject) (WorkflowCreateResponseObject, error)
	// Delete workflow by id
	// (DELETE /workflows/{workflowId})
	WorkflowDelete(ctx context.Context, request WorkflowDeleteRequestObject) (WorkflowDeleteResponseObject, error)
	// Get workflow by id
	// (GET /workflows/{workflowId})
	WorkflowGet(ctx context.Context, request WorkflowGetRequestObject) (WorkflowGetResponseObject, error)
	// Update workflow by id
	// (PUT /workflows/{workflowId})
	WorkflowUpdate(ctx context.Context, request WorkflowUpdateRequestObject) (WorkflowUpdateResponseObject, error)
	// List workflow executions by workflow id
	// (GET /workflows/{workflowId}/executions)
	WorkflowExecutionList(ctx context.Context, request WorkflowExecutionListRequestObject) (WorkflowExecutionListResponseObject, error)
	// Run workflow by id
	// (POST /workflows/{workflowId}/run)
	WorkflowRun(ctx context.Context, request WorkflowRunRequestObject) (WorkflowRunResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// QrLocationList operation middleware
func (sh *strictHandler) QrLocationList(w http.ResponseWriter, r *http.Request, params QrLocationListParams) {
	var request QrLocationListRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.QrLocationList(ctx, request.(QrLocationListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "QrLocationList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(QrLocationListResponseObject); ok {
		if err := validResponse.VisitQrLocationListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// QrLocationCreate operation middleware
func (sh *strictHandler) QrLocationCreate(w http.ResponseWriter, r *http.Request) {
	var request QrLocationCreateRequestObject

	var body QrLocationCreateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.QrLocationCreate(ctx, request.(QrLocationCreateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "QrLocationCreate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(QrLocationCreateResponseObject); ok {
		if err := validResponse.VisitQrLocationCreateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// QrLocationDelete operation middleware
func (sh *strictHandler) QrLocationDelete(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	var request QrLocationDeleteRequestObject

	request.QrLocationId = qrLocationId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.QrLocationDelete(ctx, request.(QrLocationDeleteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "QrLocationDelete")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(QrLocationDeleteResponseObject); ok {
		if err := validResponse.VisitQrLocationDeleteResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// QrLocationGet operation middleware
func (sh *strictHandler) QrLocationGet(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	var request QrLocationGetRequestObject

	request.QrLocationId = qrLocationId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.QrLocationGet(ctx, request.(QrLocationGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "QrLocationGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(QrLocationGetResponseObject); ok {
		if err := validResponse.VisitQrLocationGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// QrLocationUpdate operation middleware
func (sh *strictHandler) QrLocationUpdate(w http.ResponseWriter, r *http.Request, qrLocationId string) {
	var request QrLocationUpdateRequestObject

	request.QrLocationId = qrLocationId

	var body QrLocationUpdateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.QrLocationUpdate(ctx, request.(QrLocationUpdateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "QrLocationUpdate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(QrLocationUpdateResponseObject); ok {
		if err := validResponse.VisitQrLocationUpdateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotCommandGet operation middleware
func (sh *strictHandler) RaybotCommandGet(w http.ResponseWriter, r *http.Request, raybotCommandId string) {
	var request RaybotCommandGetRequestObject

	request.RaybotCommandId = raybotCommandId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotCommandGet(ctx, request.(RaybotCommandGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotCommandGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotCommandGetResponseObject); ok {
		if err := validResponse.VisitRaybotCommandGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotList operation middleware
func (sh *strictHandler) RaybotList(w http.ResponseWriter, r *http.Request, params RaybotListParams) {
	var request RaybotListRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotList(ctx, request.(RaybotListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotListResponseObject); ok {
		if err := validResponse.VisitRaybotListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotCreate operation middleware
func (sh *strictHandler) RaybotCreate(w http.ResponseWriter, r *http.Request) {
	var request RaybotCreateRequestObject

	var body RaybotCreateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotCreate(ctx, request.(RaybotCreateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotCreate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotCreateResponseObject); ok {
		if err := validResponse.VisitRaybotCreateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotDelete operation middleware
func (sh *strictHandler) RaybotDelete(w http.ResponseWriter, r *http.Request, raybotId string) {
	var request RaybotDeleteRequestObject

	request.RaybotId = raybotId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotDelete(ctx, request.(RaybotDeleteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotDelete")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotDeleteResponseObject); ok {
		if err := validResponse.VisitRaybotDeleteResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotGet operation middleware
func (sh *strictHandler) RaybotGet(w http.ResponseWriter, r *http.Request, raybotId string) {
	var request RaybotGetRequestObject

	request.RaybotId = raybotId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotGet(ctx, request.(RaybotGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotGetResponseObject); ok {
		if err := validResponse.VisitRaybotGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotCommandList operation middleware
func (sh *strictHandler) RaybotCommandList(w http.ResponseWriter, r *http.Request, raybotId string, params RaybotCommandListParams) {
	var request RaybotCommandListRequestObject

	request.RaybotId = raybotId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotCommandList(ctx, request.(RaybotCommandListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotCommandList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotCommandListResponseObject); ok {
		if err := validResponse.VisitRaybotCommandListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RaybotCommandCreate operation middleware
func (sh *strictHandler) RaybotCommandCreate(w http.ResponseWriter, r *http.Request, raybotId string) {
	var request RaybotCommandCreateRequestObject

	request.RaybotId = raybotId

	var body RaybotCommandCreateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RaybotCommandCreate(ctx, request.(RaybotCommandCreateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RaybotCommandCreate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RaybotCommandCreateResponseObject); ok {
		if err := validResponse.VisitRaybotCommandCreateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StepExecutionGet operation middleware
func (sh *strictHandler) StepExecutionGet(w http.ResponseWriter, r *http.Request, stepExecutionId string) {
	var request StepExecutionGetRequestObject

	request.StepExecutionId = stepExecutionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StepExecutionGet(ctx, request.(StepExecutionGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StepExecutionGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StepExecutionGetResponseObject); ok {
		if err := validResponse.VisitStepExecutionGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowExecutionGet operation middleware
func (sh *strictHandler) WorkflowExecutionGet(w http.ResponseWriter, r *http.Request, workflowExecutionId string) {
	var request WorkflowExecutionGetRequestObject

	request.WorkflowExecutionId = workflowExecutionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowExecutionGet(ctx, request.(WorkflowExecutionGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowExecutionGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowExecutionGetResponseObject); ok {
		if err := validResponse.VisitWorkflowExecutionGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// StepExecutionListByWorkflowExecutionId operation middleware
func (sh *strictHandler) StepExecutionListByWorkflowExecutionId(w http.ResponseWriter, r *http.Request, workflowExecutionId string) {
	var request StepExecutionListByWorkflowExecutionIdRequestObject

	request.WorkflowExecutionId = workflowExecutionId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.StepExecutionListByWorkflowExecutionId(ctx, request.(StepExecutionListByWorkflowExecutionIdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StepExecutionListByWorkflowExecutionId")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(StepExecutionListByWorkflowExecutionIdResponseObject); ok {
		if err := validResponse.VisitStepExecutionListByWorkflowExecutionIdResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowList operation middleware
func (sh *strictHandler) WorkflowList(w http.ResponseWriter, r *http.Request, params WorkflowListParams) {
	var request WorkflowListRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowList(ctx, request.(WorkflowListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowListResponseObject); ok {
		if err := validResponse.VisitWorkflowListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowCreate operation middleware
func (sh *strictHandler) WorkflowCreate(w http.ResponseWriter, r *http.Request) {
	var request WorkflowCreateRequestObject

	var body WorkflowCreateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowCreate(ctx, request.(WorkflowCreateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowCreate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowCreateResponseObject); ok {
		if err := validResponse.VisitWorkflowCreateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowDelete operation middleware
func (sh *strictHandler) WorkflowDelete(w http.ResponseWriter, r *http.Request, workflowId string) {
	var request WorkflowDeleteRequestObject

	request.WorkflowId = workflowId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowDelete(ctx, request.(WorkflowDeleteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowDelete")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowDeleteResponseObject); ok {
		if err := validResponse.VisitWorkflowDeleteResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowGet operation middleware
func (sh *strictHandler) WorkflowGet(w http.ResponseWriter, r *http.Request, workflowId string) {
	var request WorkflowGetRequestObject

	request.WorkflowId = workflowId

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowGet(ctx, request.(WorkflowGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowGetResponseObject); ok {
		if err := validResponse.VisitWorkflowGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowUpdate operation middleware
func (sh *strictHandler) WorkflowUpdate(w http.ResponseWriter, r *http.Request, workflowId string) {
	var request WorkflowUpdateRequestObject

	request.WorkflowId = workflowId

	var body WorkflowUpdateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowUpdate(ctx, request.(WorkflowUpdateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowUpdate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowUpdateResponseObject); ok {
		if err := validResponse.VisitWorkflowUpdateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowExecutionList operation middleware
func (sh *strictHandler) WorkflowExecutionList(w http.ResponseWriter, r *http.Request, workflowId string, params WorkflowExecutionListParams) {
	var request WorkflowExecutionListRequestObject

	request.WorkflowId = workflowId
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowExecutionList(ctx, request.(WorkflowExecutionListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowExecutionList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowExecutionListResponseObject); ok {
		if err := validResponse.VisitWorkflowExecutionListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// WorkflowRun operation middleware
func (sh *strictHandler) WorkflowRun(w http.ResponseWriter, r *http.Request, workflowId string) {
	var request WorkflowRunRequestObject

	request.WorkflowId = workflowId

	var body WorkflowRunJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.WorkflowRun(ctx, request.(WorkflowRunRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WorkflowRun")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(WorkflowRunResponseObject); ok {
		if err := validResponse.VisitWorkflowRunResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FRrFdS8ttLRa19twdbr6fwAAAP//9Fv8p9J+AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
