// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: raybot_command.sql

package sqlcpg

import (
	"context"
	"encoding/json"
	"time"
)

const raybotCommandDeleteByRaybotID = `-- name: RaybotCommandDeleteByRaybotID :exec
DELETE FROM raybot_commands
WHERE raybot_id = $1
`

func (q *Queries) RaybotCommandDeleteByRaybotID(ctx context.Context, db DBTX, raybotID string) error {
	_, err := db.Exec(ctx, raybotCommandDeleteByRaybotID, raybotID)
	return err
}

const raybotCommandGetByID = `-- name: RaybotCommandGetByID :one
SELECT id, raybot_id, type, status, inputs, outputs, error, created_at, updated_at, completed_at FROM raybot_commands
WHERE id = $1
`

func (q *Queries) RaybotCommandGetByID(ctx context.Context, db DBTX, id string) (RaybotCommand, error) {
	row := db.QueryRow(ctx, raybotCommandGetByID, id)
	var i RaybotCommand
	err := row.Scan(
		&i.ID,
		&i.RaybotID,
		&i.Type,
		&i.Status,
		&i.Inputs,
		&i.Outputs,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const raybotCommandGetOneByRaybotIDAndStatus = `-- name: RaybotCommandGetOneByRaybotIDAndStatus :one
SELECT id, raybot_id, type, status, inputs, outputs, error, created_at, updated_at, completed_at FROM raybot_commands
WHERE raybot_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT 1
`

type RaybotCommandGetOneByRaybotIDAndStatusParams struct {
	RaybotID string `json:"raybot_id"`
	Status   string `json:"status"`
}

func (q *Queries) RaybotCommandGetOneByRaybotIDAndStatus(ctx context.Context, db DBTX, arg RaybotCommandGetOneByRaybotIDAndStatusParams) (RaybotCommand, error) {
	row := db.QueryRow(ctx, raybotCommandGetOneByRaybotIDAndStatus, arg.RaybotID, arg.Status)
	var i RaybotCommand
	err := row.Scan(
		&i.ID,
		&i.RaybotID,
		&i.Type,
		&i.Status,
		&i.Inputs,
		&i.Outputs,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const raybotCommandInsert = `-- name: RaybotCommandInsert :exec
INSERT INTO raybot_commands (
    id,
    raybot_id,
    type,
    status,
    inputs,
	outputs,
	error,
	completed_at,
	created_at,
	updated_at
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
`

type RaybotCommandInsertParams struct {
	ID          string          `json:"id"`
	RaybotID    string          `json:"raybot_id"`
	Type        string          `json:"type"`
	Status      string          `json:"status"`
	Inputs      json.RawMessage `json:"inputs"`
	Outputs     json.RawMessage `json:"outputs"`
	Error       *string         `json:"error"`
	CompletedAt *time.Time      `json:"completed_at"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

func (q *Queries) RaybotCommandInsert(ctx context.Context, db DBTX, arg RaybotCommandInsertParams) error {
	_, err := db.Exec(ctx, raybotCommandInsert,
		arg.ID,
		arg.RaybotID,
		arg.Type,
		arg.Status,
		arg.Inputs,
		arg.Outputs,
		arg.Error,
		arg.CompletedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const raybotCommandMarkFailed = `-- name: RaybotCommandMarkFailed :exec
UPDATE raybot_commands
SET
    status = 'FAILED',
    error = $1,
    updated_at = NOW()
WHERE raybot_id = $2
    AND (status = 'PENDING' OR status = 'IN_PROGRESS')
`

type RaybotCommandMarkFailedParams struct {
	Error    *string `json:"error"`
	RaybotID string  `json:"raybot_id"`
}

func (q *Queries) RaybotCommandMarkFailed(ctx context.Context, db DBTX, arg RaybotCommandMarkFailedParams) error {
	_, err := db.Exec(ctx, raybotCommandMarkFailed, arg.Error, arg.RaybotID)
	return err
}

const raybotCommandStatusGetByID = `-- name: RaybotCommandStatusGetByID :one
SELECT status FROM raybot_commands
WHERE id = $1
`

func (q *Queries) RaybotCommandStatusGetByID(ctx context.Context, db DBTX, id string) (string, error) {
	row := db.QueryRow(ctx, raybotCommandStatusGetByID, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const raybotCommandUpdate = `-- name: RaybotCommandUpdate :one
UPDATE raybot_commands
SET
	status = CASE WHEN $1::boolean THEN $2 ELSE status END,
	outputs = CASE WHEN $3::boolean THEN $4 ELSE outputs END,
	error = CASE WHEN $5::boolean THEN $6 ELSE error END,
	completed_at = CASE WHEN $7::boolean THEN $8 ELSE completed_at END,
	updated_at = NOW()
WHERE id = $9
RETURNING id, raybot_id, type, status, inputs, outputs, error, created_at, updated_at, completed_at
`

type RaybotCommandUpdateParams struct {
	SetStatus      bool            `json:"set_status"`
	Status         string          `json:"status"`
	SetOutputs     bool            `json:"set_outputs"`
	Outputs        json.RawMessage `json:"outputs"`
	SetError       bool            `json:"set_error"`
	Error          *string         `json:"error"`
	SetCompletedAt bool            `json:"set_completed_at"`
	CompletedAt    *time.Time      `json:"completed_at"`
	ID             string          `json:"id"`
}

func (q *Queries) RaybotCommandUpdate(ctx context.Context, db DBTX, arg RaybotCommandUpdateParams) (RaybotCommand, error) {
	row := db.QueryRow(ctx, raybotCommandUpdate,
		arg.SetStatus,
		arg.Status,
		arg.SetOutputs,
		arg.Outputs,
		arg.SetError,
		arg.Error,
		arg.SetCompletedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i RaybotCommand
	err := row.Scan(
		&i.ID,
		&i.RaybotID,
		&i.Type,
		&i.Status,
		&i.Inputs,
		&i.Outputs,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
